\documentclass[a4paper]{ltxdoc}
%\input{pgfmanual-dvipdfm.cfg}
%\input{../../text-en/pgfmanual-en-main-preamble}
\usepackage[version=latest]{pgf}
\usepackage{xkeyval,calc,listings,tikz,fp,amsmath,amssymb}
\usepackage[T1]{fontenc}% big thanks to samcarter!
\usepackage{makeidx}
\makeindex
\usepackage{hyperref}
\hypersetup{%
        colorlinks=true,
        linkcolor=blue,
        filecolor=blue,
        urlcolor=blue,
        citecolor=blue,
        pdfborder=0 0 0,
}
\makeatletter          % see https://tex.stackexchange.com/q/33946
\input{pgfmanual.code} % 
\makeatother           % 
\input{pgfmanual-en-macros.tex} % link from
% /usr/local/texlive/2019/texmf-dist/doc/generic/pgf/macros/pgfmanual-en-macros.tex
% or the equivalent on your installation
\def\pgfautoxrefs{1}
\usetikzlibrary{3dtools,calc}
\begin{document}
\section{3D Tools}
\begin{tikzlibrary}{3dtools}
    This library provides additional tools to create 3d-like pictures. It is a
	collection of reasonably working tools, which however is not streamlined,
	and may be subject to substantial changes if the library ever happens to get
	further developed.
\end{tikzlibrary}

\tikzname\ has the |3d| and |tpp| libraries which deal with the projections of
three-dimensional drawings. This library provides some means to manipulate
the coordinates. It supports linear combinations of vectors, vector and scalar
products.

\noindent\textbf{Note:} Hopefully this library is only temporary and its
contents will be absorbed in slightly extended versions of the |3d| and |calc|
libraries. The cleanest way will be to record a screen depth when ``saving'' a
coordinate with \tikzname. However, this would require changes at the level of
|tikz.code.tex| and can only be done consistently if the maintainer(s) of
\tikzname\ support this. Note also that it is quite conceivable that the viewers
will in the future will be able to achieve 3d ordering, so, in a way, recording
the screen depth will become almost mandatory at a given point. 

\subsection{Coordinate computations}
\label{sec:3DCoordinateComputations}


The |3dtools| library has some options and styles for coordinate computations.
\begin{key}{/tikz/3d parse}
        Parses an expression and inserts the result in form of a coordinate.
\end{key}
\begin{key}{/tikz/3d coordinate}
        Allow one to define a 3d coordinate from other coordinates.
\end{key}
Both keys support both symbolic and explicit coordinates.

\begin{codeexample}[width=6cm]
\begin{tikzpicture}
 \path (1,2,3) coordinate (A) 
  (2,3,-1) coordinate (B) 
  (-1,-2,1) coordinate (C)
  [3d parse={0.25*(1,2,3)x(B)}] 
  	coordinate(D)
  [3d parse={0.25*(C)x(B)}] 
  	coordinate(E);
 \path foreach \X in {A,...,E} 
 {(\X) node[fill,inner sep=1pt,
 label=above:$\X$]{}};
\end{tikzpicture}
\end{codeexample}

Notice that, as of now, only the syntax |\path (1,2,3) coordinate (A);| works,
i.e.\ |\coordinate (A) at (1,2,3);| does \emph{not} work, but leads to error
messages.

\begin{codeexample}[width=6cm]
\begin{tikzpicture}
 \path (1,2,3) coordinate (A) 
  (2,3,-1) coordinate (B) 
  (-1,-2,1) coordinate (C)
  [3d coordinate={(D)=0.25*(1,2,3)x(B)},
  3d coordinate={(E)=0.25*(C)x(B)},
  3d coordinate={(F)=(A)-(B)},];
 \path foreach \X in {A,...,E} 
 {(\X) node[fill,inner sep=1pt,
 label=above:$\X$]{}};
\end{tikzpicture}
\end{codeexample}

The actual parsings are done by the function |\pgfmathtdparse| that allows one
to parse 3d expressions. The supported vector operations are |+| (addition $+$),
|-| (subtraction $-$), |*| (multiplication of the vector by a scalar), |x|
(vector product $\times$) and |o| (scalar product).

\begin{command}{\pgfmathtdparse{\marg{x}}}
   Parses 3d expressions.
\end{command}

\begin{math-function}{TDx("\mvar{vector}")}
   Yields the $x$-component of a 3d expression.
\end{math-function}

\begin{math-function}{TDy("\mvar{vector}")}
   Yields the $y$-component of a 3d expression.
\end{math-function}

\begin{math-function}{TDz("\mvar{vector}")}
   Yields the $z$-component of a 3d expression.
\end{math-function}

In order to pretty-print the result one may want to use |\pgfmathprintvector|,
and use the math function |TD| for parsing.

\begin{command}{\pgfmathprintvector\marg{x}}
   Pretty-prints vectors.
\end{command}


\begin{codeexample}[width=6.5cm]
\pgfmathparse{TD("0.2*(A)
-0.3*(B)+0.6*(C)")}%
$0.2\,\vec A-0.3\,\vec B+0.6\,\vec C
=(\pgfmathprintvector\pgfmathresult)$
\end{codeexample}

The alert reader may wonder why this works, i.e.\ how would \tikzname\ ``know''
what the coordinates $A$, $B$ and $C$ are. It works because the coordinates in
\tikzname\ are global, so they get remembered from the above example.

\paragraph{Warning.} The expressions that are used in the coordinates will only
be evaluated when they are retrieved. So, if you use, say, random numbers, you
will get each time a \emph{different} result.

\begin{codeexample}[width=4cm]
\begin{tikzpicture}
 \path[overlay] (rnd,rnd,rnd) 
 	coordinate (R);
 \node at (0,1)
  {\pgfmathparse{TD("(R)")}%
  $\vec R=(\pgfmathprintvector\pgfmathresult)$};	
 \node at (0,0)
  {\pgfmathparse{TD("(R)")}%
  $\vec R=(\pgfmathprintvector\pgfmathresult)$};	
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[width=5.2cm]
\pgfmathparse{TD("(1,0,0)x(0,1,0)")}%
$(1,0,0)^T\times(0,1,0)^T=
(\pgfmathprintvector\pgfmathresult)^T$
\end{codeexample}

\begin{codeexample}[width=5.2cm]
\pgfmathparse{TD("(A)o(B)")}%
$\vec A\cdot \vec B=
\pgfmathprintnumber\pgfmathresult$
\end{codeexample}

Notice that, as of now, the only purpose of brackets |(...)| is to delimit
vectors. Further, the addition |+| and subtraction |-| have a \emph{higher}
precedence than vector products |x| and scalar products |o|. That is,
|(A)+(B)o(C)| gets interpreted as $(\vec A+\vec B)\cdot\vec C$, and
|(A)+(B)x(C)| as $(\vec A+\vec B)\times\vec C$.



\begin{codeexample}[width=5.2cm]
\pgfmathparse{TD("(A)+(B)o(C)")}%
$(\vec A+\vec B)\cdot\vec C=
\pgfmathprintnumber\pgfmathresult$
\end{codeexample}

\begin{codeexample}[width=5.2cm]
\pgfmathparse{TD("(A)+(B)x(C)")}%
$(\vec A+\vec B)\times\vec C=
(\pgfmathprintvector\pgfmathresult)$
\end{codeexample}

Moreover, any expression can only have either one |o| or one |x|, or none of
these. Expressions with more of these can be accidentally right.

\begin{math-function}{axisangles("\mvar{vector}")}
   Yields the the rotation angles that transforms the vector in the $z$-axis.
   Since an axis has a residual rotation symmetry, namely the rotation around
   this axis, only two angles are required, and thus returned. In the
   conventions of section~\ref{sec:3DOrthonormalProjections}, these are the
   angles $\phi$ and $\psi$. It corresponds to the macro
   |\tdplotgetpolarcoords{\marg{x}}{\marg{y}}{\marg{z}}| from the |tikz-3dplot|
   package.
\end{math-function}

\begin{codeexample}[width=5.2cm]
\pgfmathparse{axisangles("(A)")}%
$\sphericalangle(\vec A)=
\pgfmathprintvector\pgfmathresult$
\end{codeexample}

\begin{codeexample}[width=5.2cm]
\pgfmathparse{axisangles("(A)")}%
$\sphericalangle(\vec A)=
\pgfmathprintvector\pgfmathresult$
\end{codeexample}


% \tikzset{3d/projection precomputations/.code n args={3}{%
% \pgfmathsetmacro{\pgfutil@tmpa}{TD("#2-#3o#1-#3")/TD("#2-#3o#2-#3")}%
% \pgfmathsetmacro{\pgfutil@tmpb}{TD("#3+\pgfutil@tmpa*#2-\pgfutil@tmpa*#3")}%
% },3d/projection of/.style args={#1 on #2--#3}{%
% 3d/projection precomputations={#1}{#2}{#3},%
% insert path={[3d parse={(\pgfutil@tmpb)}]}
% }}
% 

\begin{key}{/tikz/3d/projection of}
    Allows one to compute the projection of a point on a line.
\end{key}

The following code example illustrates the usage. It also makes use of the
|install view| key, which we describe in
section~\ref{sec:3DOrthonormalProjections}. 

\begin{codeexample}[width=4.5cm]
\begin{tikzpicture}[3d/install view={%
	phi=110,psi=0,theta=60}]
 \draw
   (2,1,2) coordinate[label=above:{$A$}] (A) 
   (1,2,1) coordinate[label=below:{$B$}] (B) --
   (2,0,0) coordinate[label=below:{$C$}] (C);
 \path[3d/projection of={(A) on (B)--(C)}] 
   coordinate (P);
 \draw[dashed] (A) -- (P);
\end{tikzpicture}
\end{codeexample}

\subsection{Orthonormal projections}
\label{sec:3DOrthonormalProjections}

This library can be used together with the |tikz-3dplot| package. It also has
its own means to install orthonormal projections. Orthonormal projections emerge
from subjecting 3-dimensional vectors to orthogonal transformations and
projecting them to 2 dimensions. They are not to be confused with the
perspective projections, which are more realistic and supported by the |tpp|
library. Orthonormal projections may be thought of a limit of perspective
projections at large distances, where large means that the distance of the
observer is much larger than the dimensions of the objects that get depicted. 

\begin{key}{/tikz/3d/install view}
        Installs a 3d orthonormal projection.
\end{key}

The initial projection is such that $x$ is right an $y$ is up, as if we had no
third direction.

\begin{codeexample}[width=2cm]
\begin{tikzpicture}[3d/install view]
 \draw[-stealth] (0,0,0) -- (1,0,0) 
  node[pos=1.2] {$x$};
 \draw[-stealth] (0,0,0) -- (0,1,0) 
  node[pos=1.2] {$y$};
 \draw[-stealth] (0,0,0) -- (0,0,1) 
  node[pos=1.2] {$z$};
\end{tikzpicture}
\end{codeexample}



The 3d-like picture emerge by rotating the view. The conventions for the
parametrization of the orthogonal rotations in terms of three rotation angles
$\phi$, $\psi$ and $\theta$ are
\[ O(\phi,\psi,\theta)=\begin{pmatrix}
 c_{\phi}\,c_{\psi} & s_{\phi}\,c_{\psi} & -s_{\psi} \\
 c_{\phi}\,s_{\psi}\,s_{\theta}-s_{\phi}\,c_{\theta} & 
 s_{\phi}\,s_{\psi}\,s_{\theta}+c_{\phi}\,c_{\theta} 
 & c_{\psi}\,s_{\theta} \\
 c_{\phi}\,s_{\psi}\,c_{\theta}+s_{\phi}\,s_{\theta} 
 & s_{\phi}\,s_{\psi}\,c_{\theta}-c_{\phi}\,s_{\theta} & c_{\psi}\,c_{\theta} \\
%   c_{\phi}\,c_{\psi}
% &  s_{\psi} 
% &  -c_{\phi}\,c_{\theta}+s_{\phi}\,s_{\psi}\,s_{\theta} \\
%   -s_{\phi}\,c_{\theta}-c_{\phi}\,s_{\psi}\,s_{\theta} 
% &  c_{\psi}\,s_ {\theta}
% &  c_{\phi}\,s_{\theta}+s_{\phi}\,c_{\theta}\,s_{\psi} \\
%   -c_{\phi}\,s_{\psi}\,c_{\theta}+s_{\phi}\,s_{\theta} 
% &  c_{\psi}\,c_{\theta}
% & c_{\psi}\,c_{\theta}
\end{pmatrix}\;.
\]
Here, $c_\phi:=\cos\phi$, $s_\phi:=\sin\phi$ and so on.
\begin{key}{/tikz/3d/phi (initially 0)}
        3d rotation angle.
\end{key}
\begin{key}{/tikz/3d/psi (initially 0)}
        3d rotation angle.
\end{key}
\begin{key}{/tikz/3d/theta (initially 0)}
        3d rotation angle.
\end{key}
The rotation angles can be used to define the view. The conventions are chosen
in such a way that they resemble those of the |tikz-3dplot| package, which gets
widely used. This matrix can be written as 
\[O(\phi,\psi,\theta)=R_x(\theta)\cdot R_y(\psi)\cdot R_z(\phi)\;,\]
where 
\begin{align*}
 R_x(\theta)&=
 \begin{pmatrix}
  1 & 0 & 0 \\
  0 & \cos (\theta ) & \sin (\theta ) \\
  0 & -\sin (\theta ) & \cos (\theta ) \\
 \end{pmatrix}\;,&
 R_y(\psi)&=
 \begin{pmatrix}
  \cos (\psi ) & 0 & -\sin (\psi ) \\
  0 & 1 & 0 \\
  \sin (\psi ) & 0 & \cos (\psi ) \\
 \end{pmatrix}\;,\\
 R_z(\phi)&=
 \begin{pmatrix}
  1 & 0 & 0 \\
  0 & \cos (\phi ) & \sin (\phi ) \\
  0 & -\sin (\phi ) & \cos (\phi ) \\
 \end{pmatrix}
\end{align*}
are rotations about the $x$, $y$ and $z$ axis, respectively. 
For $\psi=0$, $O(\phi,0,\theta)=R^d(\theta_d,\phi_d)$ from the `tikz-3dplot`
package. Note, however, that there seems to be an inconsistency in equation
(2.1) of that package.\footnote{I do not know how to contact the author.}

\begin{codeexample}[width=2.5cm]
\begin{tikzpicture}[3d/install view={phi=110,psi=0,theta=70}]
 \draw[-stealth] (0,0,0) -- (1,0,0) 
  node[pos=1.2] {$x$};
 \draw[-stealth] (0,0,0) -- (0,1,0) 
  node[pos=1.2] {$y$};
 \draw[-stealth] (0,0,0) -- (0,0,1) 
  node[pos=1.2] {$z$};
\end{tikzpicture}
\end{codeexample}

\subsection{Predefined pics}

\begin{key}{/tikz/pics/3d circle through 3 points=\meta{options} (initially empty)}
        Draws a circle through 3 points in 3 dimensions. If the three
		coordinates are close to linearly dependent, the circle will not be
		drawn.
\end{key}
\begin{key}{/tikz/3d circle through 3 points/A (initially {(1,0,0)})}
        First coordinate. Can be either symbolic or explicit. Symbolic
		coordinates need to be defined via 
		|\path (x,y,z) coordinate (name);|.
\end{key}
\begin{key}{/tikz/3d circle through 3 points/B (initially {(0,1,0)})}
        Second coordinate, like above.
\end{key}
\begin{key}{/tikz/3d circle through 3 points/C (initially {(0,0,1)})}
        Third coordinate, like above.
\end{key}
\begin{key}{/tikz/3d circle through 3 points/center name (initially {M})}
        Name of the center coordinate that will be derived.
\end{key}
\begin{key}{/tikz/3d circle through 3 points/auxiliary coordinate prefix (initially {tmp})}
		In \tikzname\ the coordinates are global. The code for the circle is
		more comprehensible if named coordinates are introduced. Their names
		will begin with this prefix. Changing the prefix will allow users to
		avoid overwriting existing coordinates.
\end{key}

\begin{codeexample}[width=2.5cm]
\begin{tikzpicture}[3d/install view={phi=30,psi=0,theta=70}]
 \foreach \X in {A,B,C}
 {\pgfmathsetmacro{\myx}{3*(rnd-1/2)}
 \pgfmathsetmacro{\myy}{3*(rnd-1/2)}
 \pgfmathsetmacro{\myz}{3*(rnd-1/2)}
 \path (\myx,\myy,\myz) coordinate (\X);}
 \path pic{3d circle through 3 points={%
 A={(A)},B={(B)},C={(C)},center name=MM}};
  \foreach \X in {A,B,C,MM}
  {\fill (\X) circle[radius=1.5pt] 
  node[above]{$\X$};}
\end{tikzpicture}
\end{codeexample}


\begin{key}{/tikz/pics/3d incircle=\meta{options} (initially empty)}
        Inscribes a circle in a triangle in 3 dimensions.
\end{key}
\begin{key}{/tikz/3d incircle/A (initially {(1,0,0)})}
        First coordinate. Can be either symbolic or explicit. 
\end{key}
\begin{key}{/tikz/3d incircle/B (initially {(0,1,0)})}
        Second coordinate, like above.
\end{key}
\begin{key}{/tikz/3d incircle/C (initially {(0,0,1)})}
        Third coordinate, like above.
\end{key}
\begin{key}{/tikz/3d incircle/center name (initially {I})}
        Name of the center coordinate that will be derived.
\end{key}
\begin{key}{/tikz/3d incircle/auxiliary coordinate prefix (initially {tmpp})}
		In \tikzname\ the coordinates are global. The code for the circle is
		more comprehensible if named coordinates are introduced. Their names
		will begin with this prefix. Changing the prefix will allow users to
		avoid overwriting existing coordinates.
\end{key}

\begin{codeexample}[width=2.5cm]
\begin{tikzpicture}[3d/install view={phi=110,psi=0,theta=70}]
 \draw
   (8,5,5) coordinate[label=above:{$A$}] (A) --
   (1,2,0) coordinate[label=below:{$B$}] (B) --
   (5,-5,0) coordinate[label=below:{$C$}] (C) -- cycle;
 \path pic[red,dashed]{3d incircle={% 
 A={(A)},B={(B)},C={(C)},center name=I}};  
 \draw (I) -- (tmppa) (I) -- (tmppb) (I)  -- (tmppc);
\end{tikzpicture}
\end{codeexample}


\begin{key}{/tikz/pics/ycylinder (initially empty)}
 A cylinder in the $y$-direction. This pic requires the |calc| library. 
 As of now it does only work for |psi=0|.
\end{key}
\begin{key}{/tikz/pics/3d/r (initially 1)}
 Key for radii, e.g.\ of cylinders.
\end{key}
\begin{key}{/tikz/pics/3d/h (initially 1)}
 Key for heights,  e.g.\ of cylinders.
\end{key}
\begin{key}{/tikz/pics/3d/mantle (initially draw)}
 Style for cylinder mantle. If no fill option is specified, it will be shaded.
\end{key}
\begin{key}{/tikz/pics/3d/top (initially draw)}
 Style for cylinder top. 
\end{key}

% ({sin(\tdplotmaintheta)*sin(\tdplotmainphi)},
%     {-1*sin(\tdplotmaintheta)*cos(\tdplotmainphi)},
%     {cos(\tdplotmaintheta)})

\begin{codeexample}[width=3cm]
\begin{tikzpicture}[3d/install view={phi=30,psi=0,theta=80}]
 \pic{ycylinder={r=0.4,h=3,
 top/.style={fill=blue}}};
\end{tikzpicture}
\end{codeexample}

To do:
\begin{itemize}
 \item transform to plane given by three non-degenerate coordinates
 \item transform to plane given by normal and one point
 \item maybe layering/visibility
\end{itemize}

\subsection{3D-like decorations}

\begin{key}{/tikz/decorations/3d complete  coil}
        3d-like coil where the front is thicker than the back.
\end{key}

\begin{key}{/tikz/decorations/3d coil closed}
        Indicates that the coil is closed.
\end{key}


\begin{codeexample}[width=8cm]
\begin{tikzpicture}
\draw[decoration={3d coil color=red,aspect=0.35, segment length=3.1mm, 
amplitude=3mm,3d complete  coil},
decorate] (0,1) -- (0,6);
\draw[decoration={3d coil color=blue,3d coil opacity=0.9,aspect=0.5, 
segment length={2*pi*3cm/50}, amplitude=5mm,3d complete coil,
3d coil closed},
decorate] (5,3.5) circle[radius=3cm];
\end{tikzpicture}
\end{codeexample}


\end{document}


\tdplotsetmaincoords{70}{110} 
\begin{tikzpicture}
 \begin{scope}[local bounding box=tests,tdplot_main_coords]
 % to work with this library, you need to define the cordinate
 % with \path (<x>,<y>,<z>) coordinate (<name>);
  \path (0,0,0) coordinate (O) 
  (1,2,3) coordinate (A) 
  (2,3,-1) coordinate (B) 
  (-1,-2,1) coordinate (C)
  % you can use 3d parse (clumsy)
  [3d parse={0.25*(A)x(B)}] coordinate(D)
  % you can use 3d coordinate to define a new coordinate from existing ones
  [3d coordinate={(E)=0.2*(A)-0.3*(B)+0.6*(C)}] 
  [3d coordinate={(H)=0.2*(A)-0.3*(B)+0.6*(C)}]; 
  \draw (A) -- (B) -- (C) -- (D) -- (E) -- cycle; 
 \end{scope}
 %\RawCoord yields the components
 \edef\tempD{\RawCoord(D)} 
 \edef\tempE{\RawCoord(E)} 
 \edef\tempH{\RawCoord(H)} 
 \node[below right,align=left] at (tests.south west) 
  {$(D)=\tempD$,\\ $(E)=\tempE$,\\ $(H)=\tempH$}; 
\end{tikzpicture} 

\noindent% clumsy parser
$\tdparse{(A)+0.3*(B)>(A)+0.3(B)}=(\pgfmathresult)$

\noindent% parsing inside \pgfmathparse. You need to wrap the argument in "..."
\pgfmathparse{TD("0.2*(A)-0.3*(B)+0.6*(C)")}%
$0.2\,\vec A-0.3\,\vec B+0.6\vec C=(\pgfmathresult)$

%one can parse with the same parser vector products
\noindent\pgfmathparse{TD("0.5*(A)x(B)")}%
$0.5\,\vec A\times\vec B=(\pgfmathresult)$
%(note, however, that something like (A)x(B)x(C) does NOT work)

%as well as scalar products
\noindent\pgfmathparse{TD("(A)+(C)o(B)")}%
$\left(\begin{array}{@{}c@{}}1\\ 0\\ 0\end{array}\right)$
%(note, however, that + and - have higher precedence than o)\end{document}


\end{document}

\endinput
